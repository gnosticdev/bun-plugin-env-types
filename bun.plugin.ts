import { type BunPlugin } from 'bun'
import path from 'node:path'

export type PluginOptions = {
	/**
	 * The .env files to add to the env.d.ts file.
	 * If not provided, the plugin will search for .env files using the `glob` option.
	 * _Notes:_ If you provide this option, the `glob` option will be ignored.
	 * @default undefined
	 */
	envFiles?: string[] | string
	/**
	 * The name of the env.d.ts file
	 * @default 'env.d.ts'
	 */
	dtsFile?: string
	/**
	 * The glob pattern to search for .env files
	 * @default '.env*'
	 */
	glob?: string
	/**
	 * Generate a timestamp at the top of the env.d.ts file so you know when each build occurs
	 * @default true
	 */
	timestamp?: boolean
	/**
	 * .env files to ignore
	 * @default
	 * ['.env.example']
	 */
	ignore?: string[]
}

type FullOptions = Required<Omit<PluginOptions, 'envFiles'>> &
	Pick<PluginOptions, 'envFiles'>

const MOD_LINE = `
//---------------------------------------------------------------------//
//-----------------------ADD YOUR CODE BELOW---------------------------//
//---------------------------------------------------------------------//
`

/**
 * Generate TypeScript definitions for all .env files in the project.
 *
 * Scans the project for .env files using `Bun.glob`, then inserts them into a env.d.ts file under the `NodeJS.ProcessEnv` namespace, and Bun.Env interface.
 *
 * You can add your own custom global types to the env.d.ts file by adding them below the generated type dets.
 * @param pluginOpts - the options for the plugin
 * @example
 * ```toml
 * # bunfig.toml
 * # add to bunfig.toml under `preload` to run before any `bun run` command.
 * preload = ["./bun.plugin.ts"]
 * ```
 * @example
 * ```ts
 * // build.ts
 * import envPlugin from 'bun-plugin-env-types'
 *
 * const build = await Bun.build({
 *    entrypoints: ['./build.ts'],
 *    plugins: [envPlugin()],
 * })
 * ```
 */
export default function bunEnvPlugin(pluginOpts?: PluginOptions): BunPlugin {
	const defaults: PluginOptions = {
		dtsFile: 'env.d.ts',
		glob: '.env*',
		timestamp: true,
		ignore: ['.env.example'],
		envFiles: undefined,
	}
	// just in case the user provides an option that is undefined
	const filteredOptions: PluginOptions = pluginOpts
		? Object.fromEntries(
				Object.entries(pluginOpts).map(([key, value]) => [
					key,
					value === undefined ? defaults[key as keyof PluginOptions] : value,
				]),
		  )
		: defaults
	const mergedOpts = { ...defaults, ...filteredOptions } as FullOptions

	return {
		name: 'bun-plugin-env-types',
		setup: async () => {
			const envGlob = new Bun.Glob(mergedOpts.glob)
			const envFiles =
				mergedOpts.envFiles ??
				(
					await Array.fromAsync(envGlob.scan({ dot: true, absolute: false }))
				).filter((file) => !mergedOpts.ignore.some((ig) => ig.endsWith(file)))

			const typeDefinitions = new Set<string>()
			if (envFiles.length === 0) {
				throw new Error(
					`No .env files found. Please add a .env file to the project, or provide the 'envFiles' option to the plugin.`,
				)
			}

			for await (const file of envFiles) {
				const isIgnored = mergedOpts.ignore?.includes(path.basename(file))
				if (isIgnored) {
					continue
				}

				const envContent = await Bun.file(file).text()
				// filter out comments and empty lines
				const filtered = envContent
					.split('\n')
					.filter((line) => line.trim() !== '' && !line.trim().startsWith('#'))
				for (const line of filtered) {
					const [key, value] = line.split('=')
					if (!key || !value) continue
					typeDefinitions.add(`${key.trim()}: string;`)
				}
			}
			if (typeDefinitions.size === 0) {
				console.warn(
					'no env variables found in .env files, with the given plugin options',
				)
			}
			await createEnv({
				typeDefs: typeDefinitions,
				timestamp: mergedOpts.timestamp,
				envDtsFile: mergedOpts.dtsFile,
			})
		},
	}
}

async function createEnv({
	typeDefs,
	envDtsFile,
	timestamp,
}: { typeDefs: Set<string>; envDtsFile: string; timestamp?: boolean }) {
	const comment = timestamp ? new Date().toLocaleString() : ''
	const dtsContent = generateDtsString(typeDefs, comment)
	// clear the file up to the mod line
	const file = Bun.file(envDtsFile)
	if (await file.exists()) {
		const content = await file.text()
		const modLine = content.indexOf(MOD_LINE)
		if (modLine !== -1) {
			// must concat old and new content bc Bun.write doesn't append
			const oldContent = content.slice(modLine, content.length)
			await Bun.write(envDtsFile, dtsContent + oldContent)
			return
		}
	}
	// Write the env.d.ts file
	await Bun.write(envDtsFile, `${dtsContent + MOD_LINE}\n`)
}

function generateDtsString(typeDefs: Set<string>, timestamp?: string) {
	let defsContent = ''
	for (const def of typeDefs) {
		defsContent += `\t\t${def}\n`
	}
	const timeString = timestamp
		? `// Generated by Bun plugin at ${timestamp}\n`
		: ''
	const dtsContent = `${timeString}
declare namespace NodeJS {
    export interface ProcessEnv {
${defsContent}    }
}

`
	return dtsContent
}
