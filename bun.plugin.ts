import { plugin, type BunPlugin } from 'bun'
import path from 'node:path'

export type PluginOpts = {
	/**
	 * The .env files to add to the env.d.ts file.
	 * @default - all .env files in the project
	 */
	envFiles?: string[] | string
	/**
	 * The name of the env.d.ts file
	 * @default - 'env.d.ts'
	 */
	dtsFile: string
	/**
	 * The glob pattern to search for .env files. Overrides `envFiles`
	 * @default - '.env*'
	 */
	glob: string
	/**
	 * Generate a timestamp at the top of the env.d.ts file so you know when each build occurs
	 * @default - true
	 */
	timestamp?: boolean
}

const MOD_LINE = `
//---------------------------------------------------------------------//
//-----------------------ADD YOUR CODE BELOW---------------------------//
//---------------------------------------------------------------------//
`

plugin(bunEnvPlugin())

/**
 * Generate TypeScript definitions for all .env files in the project.
 *
 * Scans the project for .env files using `Bun.glob`, then inserts them into a env.d.ts file under the `NodeJS.ProcessEnv` namespace, and Bun.Env interface.
 *
 * You can add your own custom global types to the env.d.ts file by adding them below the generated type dets.
 * @param opts - the options for the plugin
 * @example
 * ```toml
 * # bunfig.toml
 * # add to bunfig.toml under `preload` to run before any `bun run` command.
 * preload = ["./bun.plugin.ts"]
 * ```
 * @example
 * ```ts
 * // build.ts
 * import envPlugin from 'bun-plugin-env-types'
 *
 * const build = await Bun.build({
 *    entrypoints: ['./build.ts'],
 *    plugins: [envPlugin()],
 * })
 * ```
 */
export default function bunEnvPlugin(
	opts: PluginOpts = { dtsFile: 'env.d.ts', glob: '.env*', timestamp: true },
): BunPlugin {
	return {
		name: 'bun-plugin-env',
		setup: async () => {
			const envGlob = new Bun.Glob(opts.glob)
			const envFiles =
				opts?.envFiles ??
				(await Array.fromAsync(envGlob.scan({ dot: true, absolute: true })))
			const typeDefinitions = new Set<string>()
			if (envFiles.length === 0) {
				console.log('No .env files found', { options: opts })
				return
			}
			for await (const file of envFiles) {
				// dont include these files in the env.d.ts
				if (
					file.endsWith('.env.d.ts') ||
					file.endsWith('.env.example') ||
					file.endsWith('.env.ts')
				)
					continue
				const envContent = await Bun.file(file).text()
				const filtered = envContent
					.split('\n')
					.filter((line) => line.trim() !== '' && !line.trim().startsWith('#'))
				for (const line of filtered) {
					const [key] = line.split('=')
					if (!key) continue
					typeDefinitions.add(`${key.trim()}: string;`)
				}
			}
			await createEnv({ typeDefs: typeDefinitions, timestamp: opts.timestamp })
			console.log('env.d.ts generated!')
		},
	}
}

async function createEnv({
	typeDefs,
	envFile,
	timestamp,
}: { typeDefs: Set<string>; envFile?: string; timestamp?: boolean }) {
	const envDtsFile = envFile ?? path.join(process.cwd(), 'env.d.ts')
	const comment = timestamp ? new Date().toLocaleString() : ''
	const dtsContent = generateDtsString(typeDefs, comment)
	// clear the file up to the mod line
	const file = Bun.file(envDtsFile)
	if (await file.exists()) {
		const content = await file.text()
		const modLine = content.indexOf(MOD_LINE)
		if (modLine !== -1) {
			// must concat old and new content bc Bun.write doesn't append
			const oldContent = content.slice(modLine, content.length)
			await Bun.write(envDtsFile, dtsContent + oldContent)
			return
		}
	}
	// Write the env.d.ts file
	await Bun.write(envDtsFile, `${dtsContent + MOD_LINE}\n`)
}

function generateDtsString(typeDefs: Set<string>, timestamp?: string) {
	let defsContent = ''
	for (const def of typeDefs) {
		defsContent += `\t\t${def}\n`
	}
	const timeString = timestamp
		? '// Generated by Bun plugin at ' + `${timestamp}\n`
		: ''
	const dtsContent = `${timeString}
declare namespace NodeJS {
    export interface ProcessEnv {
${defsContent}    }
}

declare module 'bun' {
    interface Env extends NodeJS.ProcessEnv {}
}

`
	return dtsContent
}
