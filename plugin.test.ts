import { BunFile } from 'bun'
import { afterAll, beforeAll, describe, expect, test } from 'bun:test'
import fs from 'node:fs'
import path from 'node:path'
import envPlugin, { PluginOptions } from './bun.plugin'

export class TempDir implements AsyncDisposable {
	public tempDirPath: string

	constructor(dirPath: string) {
		if (fs.existsSync(dirPath))
			throw new Error(`Temp dir already exists: ${dirPath}`)

		fs.mkdirSync(dirPath)
		this.tempDirPath = path.resolve(dirPath)
		console.log(`Created temp dir: ${this.tempDirPath}`)
	}

	async [Symbol.asyncDispose]() {
		await Bun.$`rm -rf ${this.tempDirPath}`
		console.log(`Deleting temp dir: ${this.tempDirPath}`)
	}

	public async create(dirName: string) {
		const dirPath = path.join(this.tempDirPath, dirName)
		await Bun.$`mkdir -p ${dirPath}`
		return new TempDir(dirPath)
	}
}
class TempFile implements AsyncDisposable {
	public path: string
	private contents = ''

	private constructor(tmpFile: string, contents: string) {
		this.path = path.resolve(tmpFile)
		this.contents = contents
	}

	public async append(contents: string) {
		await Bun.$`echo "${contents}" >> ${this.path}`.quiet()
		this.contents = await Bun.$`cat ${this.path}`.text()
		return this.contents
	}
	public async read() {
		this.contents = await Bun.$`cat ${this.path}`.text()
		return this.contents
	}
	async [Symbol.asyncDispose]() {
		await Bun.$`rm -rf ${this.path}`.quiet()
		console.log(`Deleting temp file: ${this.path}`)
	}
	static async create(tmpFile: string, contents: string) {
		await Bun.write(tmpFile, contents)
		return new TempFile(tmpFile, contents)
	}
}

const contents = 'const hiThere = "hi there!"\nconsole.log(hiThere)\n'
const tempEntryPoint = await TempFile.create('tmp-build.ts', contents)
const envMain = await TempFile.create('.env', 'SOME_VAR=123\nLOCAL_VAR=local')
const envExample = await TempFile.create('.env.example', 'EXAMPLE_VAR=example')
const envTest = await TempFile.create('.env.test', 'TEST_VAR=test')

afterAll(async () => {
	await tempEntryPoint[Symbol.asyncDispose]()
	await envMain[Symbol.asyncDispose]()
	await envExample[Symbol.asyncDispose]()
	await envTest[Symbol.asyncDispose]()
})

describe('default plugin options', async () => {
	let envDtsFile: BunFile
	const tmpEntry = tempEntryPoint.path
	console.log({ tmpEntry })
	beforeAll(async () => {
		console.log('running beforeAll 1')
		// create .env, .env.example, .env.test
		await Bun.build({
			entrypoints: [tempEntryPoint.path],
			plugins: [envPlugin()], // will produce env.d.ts
			outdir: 'tmp',
		})
		envDtsFile = Bun.file('env.d.ts')
	})
	afterAll(async () => {
		if (await envDtsFile.exists()) {
			fs.rmSync('env.d.ts')
		}
	})

	test('should build the temp file', () => {
		expect(fs.existsSync(tempEntryPoint.path)).toBe(true)
	})
	test('should build the env.d.ts file', async () => {
		expect(await envDtsFile.exists()).toBe(true)
	})
	test('should ignore .env.example', async () => {
		const contents = await envDtsFile.text()
		expect(contents).not.toContain('EXAMPLE_VAR: string')
	})
})

type FullOptions = Required<Omit<PluginOptions, 'envFiles'>> &
	Pick<PluginOptions, 'envFiles'>

describe('custom options', async () => {
	const envTestIgnore = await TempFile.create(
		'.env.test.ignore',
		'IGNORED_VAR=ignored',
	)
	const customOptions = {
		dtsFile: 'env.alt.d.ts', // this will be created after Bun.build
		glob: '.env.test*',
		ignore: [envTestIgnore.path, envExample.path],
		timestamp: false,
	} satisfies FullOptions
	let envDtsFile: BunFile
	beforeAll(async () => {
		await Bun.build({
			entrypoints: [tempEntryPoint.path],
			plugins: [envPlugin(customOptions)],
			outdir: 'tmp',
		})
		envDtsFile = Bun.file(customOptions.dtsFile)
	})
	afterAll(async () => {
		if (await envDtsFile.exists()) {
			fs.rmSync(customOptions.dtsFile)
		}
		await envTestIgnore[Symbol.asyncDispose]()
	})

	test('should build the env.alt.d.ts file', async () => {
		expect(await envDtsFile.exists()).toBe(true)
	})
	test('should use custom glob .env.test*', async () => {
		const dirEnvFiles = (await fs.promises.readdir(process.cwd())).filter((f) =>
			f.startsWith('.env.test'),
		)
		expect(dirEnvFiles).toBeArray()
		expect(dirEnvFiles).toBeArrayOfSize(2)
	})
	test('ignore options.ignore values', async () => {
		const contents = await envDtsFile.text()
		expect(contents).not.toInclude('IGNORED_VAR: string')
		expect(contents).not.toInclude('EXAMPLE_VAR: string')
	})
	test('should not have a timestamp', async () => {
		const contents = await envDtsFile.text()
		expect(contents).not.toInclude('// Generated by Bun plugin at')
	})
})

describe('keep the .env.d.ts file modifications', () => {
	const mods = `// This will remain on every rebuild, so you can add your own custom types here.
    declare module '*.css' {
        const content: { [className: string]: string }
        export default content
    }`
	let contentsWithMods: string
	let envDtsFile: BunFile
	beforeAll(async () => {
		await Bun.build({
			entrypoints: [tempEntryPoint.path],
			plugins: [envPlugin()],
			outdir: 'tmp',
		})
		envDtsFile = Bun.file('env.d.ts')
		contentsWithMods = ((await envDtsFile.text()) + mods).trim()
	})
	afterAll(async () => {
		if (await envDtsFile.exists()) {
			fs.rmSync('env.d.ts')
		}
	})

	test('gets the env variables', async () => {
		expect(contentsWithMods).toInclude('TEST_VAR: string')
		expect(contentsWithMods).toInclude('LOCAL_VAR: string')
	})
	test('should keep the modifications', async () => {
		expect(contentsWithMods).toInclude(mods)
	})
	test('modifications only listed once', async () => {
		expect(contentsWithMods.split(mods)).toBeArrayOfSize(2)
	})
})
